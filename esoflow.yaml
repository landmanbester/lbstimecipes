_include:
  - lb-cabs.yaml
  - (pfb)stimela_cabs.yaml
  - (lbscratch)stimela_cabs.yaml
  - (quartical)stimela_cabs.yaml

opts:
  log:
    dir: logs
    nest: 2


# Missing features
# 1) both simplyflag and crystallbal relies on MS format
# 2) QuartiCal apps need to have FIELD, DDID and SPW selection logic
# 3) can't convert over NFS

# init:
#   name: ESOINIT
#   info: Back up initial flags, do initial flagging, predict primary model and split data

#   # LB - Oleg to help do this in a neater way
#   for_loop:
#     var: ms
#     over: ms_list

#   inputs:
#     ms_list:
#       dtype: List[MS]
#       default:
#         - /net/sinatra/vault-ike/oms/MeerKAT-data/ESO137/1557347448_sdp_l0.ms  # ms1
#         - /net/sinatra/vault-ike/oms/MeerKAT-data/ESO137/1557433849_sdp_l0.ms  # ms2

#     # ms1:
#     #   default: /net/sinatra/vault-ike/oms/MeerKAT-data/ESO137/1557347448_sdp_l0.ms
#     # ms2:
#     #   default: /net/sinatra/vault-ike/oms/MeerKAT-data/ESO137/1557433849_sdp_l0.ms
#     basedir:
#       default: 'output'
#     cball_model:
#       default: 'input/fitted.PKS1934.UBand.wsclean.cat.txt'
#     nthreads:
#       default: 32
#     fmask:
#       dtype: str
#       default: ':128,2697:2705,-256:'
#       info: Channel ranges to flag

#   outputs:
#     obs_flags:
#       aliases: [backup_flag_raw.backup_dir]


#   steps:
#     backup_flag_raw:
#       cab: qcalbackup
#       info: 'Back up original MS flags'
#       params:
#         ms_path: =recipe.ms
#         zarr_dir: '{recipe.basedir}/initial_flags/'
#         column: FLAG
#         # we need a way to give explicit names to outputs here

#     backup_flagrow_raw:
#       cab: qcalbackup
#       info: 'Back up original MS flags'
#       params:
#         ms_path: '{recipe.ms}'
#         zarr_dir: '{recipe.basedir}/initial_flags'
#         column: FLAG_ROW

#     flagprim:
#       cab: simplyflag
#       params:
#         path: '{recipe.ms}'
#         field: 0
#         max_deviation: 2.5

#     flagtar:
#       cab: simplyflag
#       params:
#         path: '{recipe.ms}'
#         field: 1
#         max_deviation: 3.5

#     flag_edges:  # mapped over field?
#       cab: fledges
#       info: Apply fixed frequency flag mask
#       params:
#         ms: "{recipe.ms}"
#         row_chunk: -1
#         franges: '{recipe.fmask}'
#         nthreads: '{recipe.nthreads}'

#     backup_flag:
#       cab: qcalbackup
#       info: 'Back up original MS flags'
#       params:
#         ms_path: '{recipe.ms}'
#         zarr_dir: '{recipe.basedir}/initial_flags/'
#         column: FLAG

#     backup_flagrow:
#       cab: qcalbackup
#       info: 'Back up original MS flags'
#       params:
#         ms_path: '{recipe.ms}'
#         zarr_dir: '{recipe.basedir}/initial_flags'
#         column: FLAG_ROW

#     combine_flags:
#       cab: or_flags
#       params:
#         ms: =recipe.ms
#         fcol: =steps.backup_flag.output_name  #ed to use outputs for these
#         frcol: 'FLAG_ROW'

#     init_model:  # we should do this after convert but crystalball needs MS format
#       cab: crystalball
#       info: 'Populate MODEL_DATA column'
#       params:
#         ms: '{recipe.ms}'
#         sky_model: '{recipe.cball_model}'
#         num_sources: 1000
#         output_column: MODEL_DATA
#         num_workers: '{recipe.nthreads}'
#         memory_fraction: 0.5

#     convertprim:
#       cab: convert
#       params:
#         output: 'msdir/ms1_primary.zarr'
#         taql_where: "FIELD_ID==0"
#         input: '{recipe.ms}'

#     converttar:
#       cab: convert
#       params:
#         output: 'msdir/ms1_target.zarr'
#         taql_where: "FIELD_ID==1"
#         input: '{recipe.ms}'


crosscal:
  name: ESOCROSSCAL
  info: The ESO137 cross calibration and diagnostics recipe

  inputs:
    ms_primary:
      dtype: MS
      required: true
      abbreviation: msp
    ms_target:
      dtype: MS
      required: true
      abbreviation: mst
    basedir:
      default: 'output'
    data_column:
      default: DATA
      aliases: ['*.input_ms.data_column']
    sigma_column:
      default: SIGMA_SPECTRUM
      aliases: ['*.input_ms.sigma_column']
      info: Original std of noise used to construct weights
    weight_column:
      default: WEIGHT_SPECTRUM
      info: Modified weights to be writtent to this column
    model_column:
      dtype: str
      default: MODEL_DATA
    nthreads:
      dtype: int
      default: 32

  steps:
    # we need the restimator step here but how do we use the output??

    gkb1:
      cab: quartical
      info: GKB on the primary where
            G = time variable complex gain,  G(t)
            K = per scan delay refinement  exp(i delta(t) nu)
            B = frequency variable complex gain (bandpass)  B(nu)
      params:
        input_ms.path: '{recipe.ms_primary}'
        input_ms.time_chunk: '0'
        input_ms.freq_chunk: '0'
        input_ms.select_uv_range: [150,0]
        input_ms.group_by: [FIELD_ID,DATA_DESC_ID,SCAN_NUMBER]
        input_ms.select_corr: [0, 3]
        input_model.recipe: '{recipe.model_column}'
        input_model.apply_p_jones: false
        solver.terms: [G,K,B]
        solver.iter_recipe: [100,100,250,50,50,50,30,30,30,10,10,10,5,5,5]
        solver.propagate_flags: false
        solver.robust: true
        solver.threads: 8
        solver.reference_antenna: 43
        output.gain_directory: '{recipe.basedir}/gkb1.qc'
        output.log_directory: '{recipe.basedir}/logs.qc'
        output.overwrite: false
        output.products: [residual]
        output.columns: [RESIDUAL]
        output.flags: false
        output.apply_p_jones_inv: false
        output.net_gains: []
        mad_flags.enable: false
        dask.threads: 8
        dask.scheduler: threads
        G.type: diag_complex
        G.time_interval: 0
        G.freq_interval: 0
        K.type: delay
        K.time_interval: 0
        K.freq_interval: 0
        K.initial_estimate: true
        B.type: diag_complex
        B.time_interval: 0
        B.freq_interval: 8

    chi2plots_preflagsmooth:
      cab: surfchi2
      info: Plot mean chisq per scan and baseline before flagging
      params:
        dataout: '{recipe.basedir}/svis_preflagsmooth'
        imagesout: '{recipe.basedir}/svis_preflagsmooth'
        wcol: SIGMA_SPECTRUM
        nthreads: '{recipe.nthreads}'
        ms: '{recipe.ms_primary}'

    bsmooth:
      cab: bsmooth
      info: Smooth weighted average bandpass solutions
      params:
        gain_dir: '{recipe.basedir}/gkb1.qc/'  # result placed in smoothed.qc inside this folder
        gain_term: B
        reject_amp_thresh: 5.5
        reject_phase_thresh: 55.5
        do_plots: true
        nthreads: =recipe.nthreads
        ref_ant: 43
        dof0: 2.0
        nreweight: 10
        sigman_min: 0.005

    gsmooth:
      cab: gsmooth
      info: Transfer K offset to G and optionally smooth
      params:
        gain_dir: '{recipe.basedir}/gkb1.qc/'  # result placed in smoothed.qc inside this folder
        gain_term: G
        do_plots: true
        nthreads: =recipe.nthreads
        do_smooth: False
        ref_ant: 43

    gkb2:
      cab: quartical
      info: Continue solve for K after smoothing bandpass and compute residual for flagging
      params:
        input_ms.path: '{recipe.ms_primary}'
        input_ms.time_chunk: '0'
        input_ms.freq_chunk: '0'
        input_ms.select_uv_range: [150,0]
        input_ms.group_by: [FIELD_ID,DATA_DESC_ID,SCAN_NUMBER]
        input_ms.select_corr: [0, 3]
        input_model.recipe: '{recipe.model_column}'
        input_model.apply_p_jones: false
        solver.terms: [G,K,B]
        solver.iter_recipe: [30,30,0,20,20,0,10,10,0,5,5,0]  # both G and K can change after detrending B
        solver.propagate_flags: false
        solver.robust: true
        solver.threads: 8
        solver.reference_antenna: 43
        output.gain_directory: '{recipe.basedir}/gkb2.qc/'
        output.log_directory: '{recipe.basedir}/logs.qc'
        output.overwrite: false
        output.products: [residual]
        output.columns: [RESIDUAL]
        output.flags: false
        output.apply_p_jones_inv: false
        output.net_gains:
        mad_flags.enable: false
        dask.threads: 8
        dask.scheduler: distributed
        G.type: diag_complex
        G.time_interval: 0
        G.freq_interval: 0
        G.load_from: '{recipe.basedir}/gkb1.qc/G'
        K.type: delay
        K.time_interval: 0
        K.freq_interval: 0
        K.initial_estimate: false
        K.load_from: '{recipe.basedir}/gkb1.qc/K'
        B.type: diag_complex
        B.load_from: '{recipe.basedir}/gkb1.qc/smoothed.qc/B'
        B.time_interval: 0
        B.freq_interval: 8

    gsmooth2:
      cab: gsmooth
      info: Transfer K offset to G and optionally smooth
      params:
        gain_dir: '{recipe.basedir}/gkb2.qc/'  # result placed in smoothed.qc inside this folder
        gain_term: G
        do_plots: true
        nthreads: =recipe.nthreads
        do_smooth: False
        ref_ant: 43

    chi2plots_preflag:
      cab: surfchi2
      info: Plot mean chisq per scan and baseline before flagging
      params:
        dataout: '{recipe.basedir}/svis_preflag'
        imagesout: '{recipe.basedir}/svis_preflag'
        wcol: SIGMA_SPECTRUM
        nthreads: '{recipe.nthreads}'
        ms: '{recipe.ms_primary}'

    chi2flag:
      cab: flagchi2
      info: Flag individual data points based on their chi2 values
      params:
        wcol: SIGMA_SPECTRUM
        nthreads: '{recipe.nthreads}'
        ms: '{recipe.ms_primary}'
        flag_above: 7.5
        unflag_below: 0.0

    chi2plots_postflag:
      cab: surfchi2
      info: Plot mean chisq per scan and baseline after flagging
      params:
        dataout: '{recipe.basedir}/svis_postflag'
        imagesout: '{recipe.basedir}/svis_postflag'
        wcol: SIGMA_SPECTRUM
        nthreads: '{recipe.nthreads}'
        ms: '{recipe.ms_primary}'

    gkb3:
      cab: quartical
      info: Final solve to refine B solution intervals
      params:
        input_ms.path: '{recipe.ms_primary}'
        input_ms.time_chunk: '0'
        input_ms.freq_chunk: '0'
        input_ms.select_uv_range: [150,0]
        input_ms.group_by: [FIELD_ID,DATA_DESC_ID,SCAN_NUMBER]
        input_ms.select_corr: [0, 3]
        input_model.recipe: '{recipe.model_column}'
        input_model.apply_p_jones: false
        solver.terms: [G,K,B]
        solver.iter_recipe: [30,30,30,20,20,20,10,10,10,5,5,5]
        solver.propagate_flags: false
        solver.robust: true
        solver.threads: 8
        solver.reference_antenna: 43
        output.gain_directory: '{recipe.basedir}/gkb3.qc/'
        output.log_directory: '{recipe.basedir}/logs.qc'
        output.overwrite: false
        output.products: [residual, corrected_data, corrected_weight]
        output.columns: [RESIDUAL, CORRECTED_DATA, WEIGHT_SPECTRUM]
        output.flags: false
        output.apply_p_jones_inv: false
        output.net_gains: [G, K, B]
        mad_flags.enable: false
        dask.threads: 8
        dask.scheduler: distributed
        G.type: diag_complex
        G.time_interval: 0
        G.freq_interval: 0
        G.load_from: '{recipe.basedir}/gkb2.qc/G'
        K.type: delay
        K.time_interval: 0
        K.freq_interval: 0
        K.initial_estimate: false
        K.load_from: '{recipe.basedir}/gkb2.qc/K'
        B.type: diag_complex
        B.load_from: '{recipe.basedir}/gkb2.qc/B'
        B.time_interval: 0
        B.freq_interval: 4

    chi2plots_final:
      cab: surfchi2
      info: Plot mean chisq per scan and baseline before transfer
      params:
        dataout: '{recipe.basedir}/svis_final'
        imagesout: '{recipe.basedir}/svis_final'
        wcol: SIGMA_SPECTRUM
        nthreads: '{recipe.nthreads}'
        ms: '{recipe.ms_primary}'

    bsmooth2:
      cab: bsmooth
      info: Smooth weighted average bandpass solutions
      params:
        gain_dir: '{recipe.basedir}/gkb3.qc/'  # smoothed bandpass will be in smoothed.qc next to this folder
        gain_term: B
        reject_amp_thresh: 5.5
        reject_phase_thresh: 55.5
        do_plots: true
        per_scan: false
        nthreads: =recipe.nthreads
        ref_ant: 43
        detrend: true
        dof0: 2.0
        nreweight: 10
        sigman_min: 0.001

    gsmooth3:
      cab: gsmooth
      info: Transfer K offset to G and optionally smooth
      params:
        gain_dir: '{recipe.basedir}/gkb3.qc/'  # result placed in smoothed.qc inside this folder
        gain_term: G
        do_plots: true
        nthreads: =recipe.nthreads
        do_smooth: False
        ref_ant: 43

    gkb4:
      cab: quartical
      info: Continue solve for K after smoothing bandpass and compute residual for flagging
      params:
        input_ms.path: '{recipe.ms_primary}'
        input_ms.time_chunk: '0'
        input_ms.freq_chunk: '0'
        input_ms.select_uv_range: [150,0]
        input_ms.group_by: [FIELD_ID,DATA_DESC_ID,SCAN_NUMBER]
        input_ms.select_corr: [0, 3]
        input_model.recipe: '{recipe.model_column}'
        input_model.apply_p_jones: false
        solver.terms: [G,K,B]
        solver.iter_recipe: [30,30,0,20,20,0,10,10,0,5,5,0]  # both G and K can change after detrending B
        solver.propagate_flags: false
        solver.robust: true
        solver.threads: 8
        solver.reference_antenna: 43
        output.gain_directory: '{recipe.basedir}/gkb4.qc/'
        output.log_directory: '{recipe.basedir}/logs.qc'
        output.overwrite: true
        output.products: [residual]
        output.columns: [RESIDUAL]
        output.flags: false
        output.apply_p_jones_inv: false
        output.net_gains:
        mad_flags.enable: false
        dask.threads: 8
        dask.scheduler: distributed
        G.type: diag_complex
        G.time_interval: 0
        G.freq_interval: 0
        G.load_from: '{recipe.basedir}/gkb3.qc/G'
        K.type: delay
        K.time_interval: 0
        K.freq_interval: 0
        K.initial_estimate: false
        K.load_from: '{recipe.basedir}/gkb3.qc/K'
        B.type: diag_complex
        B.load_from: '{recipe.basedir}/gkb3.qc/smoothed.qc/B'
        B.time_interval: 0
        B.freq_interval: 4

    gsmooth4:
      cab: gsmooth
      info: Transfer K offset to G and optionally smooth
      params:
        gain_dir: '{recipe.basedir}/gkb4.qc/'  # result placed in smoothed.qc inside this folder
        gain_term: G
        do_plots: true
        nthreads: =recipe.nthreads
        do_smooth: False
        ref_ant: 43

    chi2plots_preflag2:
      cab: surfchi2
      info: Plot mean chisq per scan and baseline before flagging
      params:
        dataout: '{recipe.basedir}/svis_preflag2'
        imagesout: '{recipe.basedir}/svis_preflag2'
        wcol: SIGMA_SPECTRUM
        nthreads: '{recipe.nthreads}'
        ms: '{recipe.ms_primary}'

    chi2flag2:
      cab: flagchi2
      info: Flag individual data points based on their chi2 values
      params:
        wcol: SIGMA_SPECTRUM
        nthreads: '{recipe.nthreads}'
        ms: '{recipe.ms_primary}'
        flag_above: 3.5
        unflag_below: 0.0

    chi2plots_postflag2:
      cab: surfchi2
      info: Plot mean chisq per scan and baseline after flagging
      params:
        dataout: '{recipe.basedir}/svis_postflag2'
        imagesout: '{recipe.basedir}/svis_postflag2'
        wcol: SIGMA_SPECTRUM
        nthreads: '{recipe.nthreads}'
        ms: '{recipe.ms_primary}'

    gkb5:
      cab: quartical
      info: Final solve to refine B solution intervals
      params:
        input_ms.path: '{recipe.ms_primary}'
        input_ms.time_chunk: '0'
        input_ms.freq_chunk: '0'
        input_ms.select_uv_range: [150,0]
        input_ms.group_by: [FIELD_ID,DATA_DESC_ID,SCAN_NUMBER]
        input_ms.select_corr: [0, 3]
        input_model.recipe: '{recipe.model_column}'
        input_model.apply_p_jones: false
        solver.terms: [G,K,B]
        solver.iter_recipe: [30,30,30,20,20,20,10,10,10,5,5,5]
        solver.propagate_flags: false
        solver.robust: true
        solver.threads: 8
        solver.reference_antenna: 43
        output.gain_directory: '{recipe.basedir}/gkb5.qc/'
        output.log_directory: '{recipe.basedir}/logs.qc'
        output.overwrite: false
        output.products: [residual, corrected_data, corrected_weight]
        output.columns: [RESIDUAL, CORRECTED_DATA, WEIGHT_SPECTRUM]
        output.flags: false
        output.apply_p_jones_inv: false
        output.net_gains: [G, K, B]
        mad_flags.enable: false
        dask.threads: 8
        dask.scheduler: distributed
        G.type: diag_complex
        G.time_interval: 27
        G.freq_interval: 0
        G.load_from: '{recipe.basedir}/gkb4.qc/G'
        K.type: delay
        K.time_interval: 0
        K.freq_interval: 0
        K.initial_estimate: false
        K.load_from: '{recipe.basedir}/gkb4.qc/K'
        B.type: diag_complex
        B.load_from: '{recipe.basedir}/gkb4.qc/B'
        B.time_interval: 0
        B.freq_interval: 4

    bsmooth3:
      cab: bsmooth
      info: Smooth weighted average bandpass solutions
      params:
        gain_dir: '{recipe.basedir}/gkb5.qc/'  # smoothed bandpass will be in smoothed.qc next to this folder
        gain_term: B
        reject_amp_thresh: 5.5
        reject_phase_thresh: 55.5
        do_plots: true
        per_scan: false
        nthreads: =recipe.nthreads
        ref_ant: 43
        detrend: true
        dof0: 2.0
        nreweight: 10
        sigman_min: 0.001

    gsmooth5:
      cab: gsmooth
      info: Transfer K offset to G and optionally smooth
      params:
        gain_dir: '{recipe.basedir}/gkb5.qc/'  # result placed in smoothed.qc inside this folder
        gain_term: G
        do_plots: true
        nthreads: =recipe.nthreads
        do_smooth: False
        ref_ant: 43

    gkbf:
      cab: quartical
      info: Final solve to refine B solution intervals
      params:
        input_ms.path: '{recipe.ms_primary}'
        input_ms.time_chunk: '0'
        input_ms.freq_chunk: '0'
        input_ms.select_uv_range: [150,0]
        input_ms.group_by: [FIELD_ID,DATA_DESC_ID,SCAN_NUMBER]
        input_ms.select_corr: [0, 3]
        input_model.recipe: '{recipe.model_column}'
        input_model.apply_p_jones: false
        solver.terms: [G,K,B]
        solver.iter_recipe: [0,0,0]
        solver.propagate_flags: false
        solver.robust: false
        solver.threads: 1
        solver.reference_antenna: 43
        output.gain_directory: '{recipe.basedir}/gkbf.qc/'
        output.log_directory: '{recipe.basedir}/logs.qc'
        output.overwrite: false
        output.products: [residual, corrected_data, corrected_weight]
        output.columns: [RESIDUAL, CORRECTED_DATA, WEIGHT_SPECTRUM]
        output.flags: false
        output.apply_p_jones_inv: false
        output.net_gains: [G, K, B]
        mad_flags.enable: false
        dask.threads: 64
        dask.scheduler: distributed
        G.type: diag_complex
        G.time_interval: 27
        G.freq_interval: 0
        G.load_from: '{recipe.basedir}/gkb5.qc/G'
        K.type: delay
        K.time_interval: 0
        K.freq_interval: 0
        K.initial_estimate: false
        K.load_from: '{recipe.basedir}/gkb5.qc/K'
        B.type: diag_complex
        B.load_from: '{recipe.basedir}/gkb5.qc/B'
        B.time_interval: 0
        B.freq_interval: 4

    transfer:
      cab: quartical
      info: "Transfer gains to the targer"
      params:
        input_ms.path: '{recipe.ms_target}'
        input_ms.time_chunk: 50
        input_ms.freq_chunk: 128
        input_ms.group_by: [SCAN_NUMBER,FIELD_ID,DATA_DESC_ID]
        input_ms.select_corr: [0, 3]
        input_model.recipe: MODEL_DATA
        input_model.apply_p_jones: false
        solver.terms: [G,K,B]
        solver.iter_recipe: [0,0,0]
        solver.propagate_flags: true
        solver.robust: false
        solver.threads: 1
        solver.reference_antenna: 43
        output.gain_directory: '{recipe.basedir}/target_gains_init.qc'
        output.log_directory: '{recipe.basedir}/logs.qc'
        output.overwrite: false
        output.products: [residual]
        output.columns: [RESIDUAL]
        output.flags: true
        output.apply_p_jones_inv: false
        output.net_gains: [G, K, B]
        mad_flags.enable: false
        dask.threads: 64
        dask.scheduler: threads
        G.type: diag_complex
        G.time_interval: 1
        G.freq_interval: 0
        G.load_from: '{recipe.basedir}/gkbf.qc/G'
        K.type: delay
        K.time_interval: 1
        K.freq_interval: 0
        K.initial_estimate: false
        K.load_from: '{recipe.basedir}/gkbf.qc/K'
        B.type: diag_complex
        B.time_interval: 0
        B.freq_interval: 1
        B.load_from: '{recipe.basedir}/gkbf.qc/B'



image:
  name: ESOIMAGE
  info: An imaging step of the ESO137 self-calibration recipe

  inputs:
    ms:
      dtype: MS
      required: true
    basedir:
      default: 'output'
    data_column:
      default: DATA
    sigma_column:
      default: SIGMA_SPECTRUM
      info: Original std of noise used to construct weights
    weight_column:
      default: WEIGHT_SPECTRUM
      info: Modified weights to be written to this column
    model_column:
      dtype: str
      default: MODEL_DATA
    nband:
      default: 8
      aliases: ['*.nband']
      info: Number of imaging bands
    scheduler:
      dtype: str
      default: threads
      aliases: ['*.scheduler']
      info: Dask scheduler to use
    nthreads:
      dtype: int
      default: 64

  steps:
    init1:
      cab: pfb_init
      info: 'Initialise imaging data products'
      params:
        ms: '{recipe.ms}'
        output_filename: '{recipe.basedir}/stage1'
        data_column: =recipe.data_column
        sigma_column: =recipe.sigma_column
        gain_table: '{recipe.basedir}/target_gains_init.qc/'
        gain_term: 'GKB-net'
        integrations_per_image: -1
        channels_per_image: 256
        nthreads: =recipe.nthreads
        nworkers: 8
        nthreads_per_worker: 8
        scheduler: threads

    grid1:
      cab: pfb_grid
      info: 'Grid data for initial imaging'
      params:
        output_filename: '{recipe.basedir}/stage1'
        robustness: -1
        fits_cubes: true
        field_of_view: 2.5
        super_resolution_factor: 1.5
        nthreads: '{recipe.nthreads}'
        nworkers: 8

    spotless1:
      cab: pfb_spotless
      params:
        output_filename: '{recipe.basedir}/stage1'
        fits_cubes: true
        niter: 10
        nthreads: '{recipe.nthreads}'
        bases: 'self,db1,db2,db3,db4,db5'
        nlevels: 3
        l1reweight_from: 5
        pd_tol: 1e-4
        pd_maxit: 500
        pd_verbose: 2
        pd_report_freq: 50
        tol: 0.001
        rmsfactor: 5
        pm_tol: 1e-4

    # forward
    # grid with reweight
    # spotless
    # forward

    degrid1:
      cab: pfb_degrid
      info: Populate MODEL_DATA with model visibilities
      params:
        ms: '{recipe.ms}'
        output_filename: '{recipe.basedir}/stage1'
        nband_out: 32
        spectral_poly_order: 4


selfcal:
  name: ESOCAL
  info: Self-calibration

  inputs:
    ms:
      dtype: MS
      required: true
    basedir:
      default: 'output'
    data_column:
      default: DATA
    sigma_column:
      default: SIGMA_SPECTRUM
      info: Original std of noise used to construct weights
    weight_column:
      default: WEIGHT_SPECTRUM
      info: Modified weights to be written to this column
    model_column:
      dtype: str
      default: MODEL_DATA

  steps:
    selfcal1:
      cab: quartical
      info: Perfor a round of phase + delay selfcal
      params:
        input_ms.path: '{recipe.ms}'
        input_ms.data_column: DATA
        input_ms.sigma_column: SIGMA_SPECTRUM
        input_ms.time_chunk: 25
        input_ms.freq_chunk: 0
        input_ms.select_uv_range: [150,0]
        input_ms.group_by: [SCAN_NUMBER,FIELD_ID,DATA_DESC_ID]
        input_ms.select_corr: [0, 3]
        input_model.recipe: '{recipe.model_column}'
        input_model.apply_p_jones: false
        solver.terms: [G,K]
        solver.iter_recipe: [0,50,0,30,0,20,0,10,0,5]
        solver.propagate_flags: true
        solver.robust: true
        solver.threads: 4
        solver.reference_antenna: 57
        output.gain_directory: '{recipe.basedir}/target_gains_stage1.qc'
        output.log_directory: '{recipe.basedir}/logs.qc'
        output.overwrite: true
        output.products: [residual]
        output.columns: [RESIDUAL]
        output.flags: true
        output.apply_p_jones_inv: false
        output.net_gains: [G, K]
        mad_flags.enable: true
        mad_flags.whitening: disabled
        mad_flags.threshold_bl: 10
        mad_flags.threshold_global: 10
        mad_flags.max_deviation: 12
        dask.threads: '{recipe.nthreads}'
        dask.scheduler: threads
        G.type: complex
        G.load_from: '{recipe.basedir}/target_gains_init.qc/gains.qc/gkb-NET'
        G.interp_method: 2dlinear
        G.interp_mode: ampphase
        G.time_interval: 1
        G.freq_interval: 1
        K.type: delay_and_offset
        K.interp_method: 2dlinear
        K.interp_mode: ampphase
        K.time_interval: 5
        K.freq_interval: 0
        K.initial_estimate: false
