_include:
  # - lb-cabs.yaml
  - (pfb)stimela_cabs.yml
  # - (lbscratch)stimela_cabs.yaml
  - (quartical)stimela_cabs.yaml

opts:
  log:
    dir: logs
    nest: 2
  backend:
    select: native


# Missing features
# 1) both simplyflag and crystallbal relies on MS format
# 2) QuartiCal apps need to have FIELD, DDID and SPW selection logic

# init:
#   name: ESOINIT
#   info: Back up initial flags, do initial flagging, predict primary model and split data

#   # LB - Oleg to help do this in a neater way
#   for_loop:
#     var: ms
#     over: ms_list

#   inputs:
#     ms_list:
#       dtype: List[MS]
#       default:
#         - /net/sinatra/vault-ike/oms/MeerKAT-data/ESO137/1557347448_sdp_l0.ms  # ms1
#         - /net/sinatra/vault-ike/oms/MeerKAT-data/ESO137/1557433849_sdp_l0.ms  # ms2

#     # ms1:
#     #   default: /net/sinatra/vault-ike/oms/MeerKAT-data/ESO137/1557347448_sdp_l0.ms
#     # ms2:
#     #   default: /net/sinatra/vault-ike/oms/MeerKAT-data/ESO137/1557433849_sdp_l0.ms
#     basedir:
#       default: 'output'
#     cball_model:
#       default: 'input/fitted.PKS1934.UBand.wsclean.cat.txt'
#     nthreads:
#       default: 32
#     fmask:
#       dtype: str
#       default: ':128,2697:2705,-256:'
#       info: Channel ranges to flag

#   outputs:
#     obs_flags:
#       aliases: [backup_flag_raw.backup_dir]


#   steps:
#     backup_flag_raw:
#       cab: qcalbackup
#       info: 'Back up original MS flags'
#       params:
#         ms_path: =recipe.ms
#         zarr_dir: '{recipe.basedir}/initial_flags/'
#         column: FLAG
#         # we need a way to give explicit names to outputs here

#     backup_flagrow_raw:
#       cab: qcalbackup
#       info: 'Back up original MS flags'
#       params:
#         ms_path: '{recipe.ms}'
#         zarr_dir: '{recipe.basedir}/initial_flags'
#         column: FLAG_ROW

#     flagprim:
#       cab: simplyflag
#       params:
#         path: '{recipe.ms}'
#         field: 0
#         max_deviation: 2.5

#     flagtar:
#       cab: simplyflag
#       params:
#         path: '{recipe.ms}'
#         field: 1
#         max_deviation: 3.5

#     flag_edges:  # mapped over field?
#       cab: fledges
#       info: Apply fixed frequency flag mask
#       params:
#         ms: "{recipe.ms}"
#         row_chunk: -1
#         franges: '{recipe.fmask}'
#         nthreads: '{recipe.nthreads}'

#     backup_flag:
#       cab: qcalbackup
#       info: 'Back up original MS flags'
#       params:
#         ms_path: '{recipe.ms}'
#         zarr_dir: '{recipe.basedir}/initial_flags/'
#         column: FLAG

#     backup_flagrow:
#       cab: qcalbackup
#       info: 'Back up original MS flags'
#       params:
#         ms_path: '{recipe.ms}'
#         zarr_dir: '{recipe.basedir}/initial_flags'
#         column: FLAG_ROW

#     combine_flags:
#       cab: or_flags
#       params:
#         ms: =recipe.ms
#         fcol: =steps.backup_flag.output_name  #ed to use outputs for these
#         frcol: 'FLAG_ROW'

#     init_model:  # we should do this after convert but crystalball needs MS format
#       cab: crystalball
#       info: 'Populate MODEL_DATA column'
#       params:
#         ms: '{recipe.ms}'
#         sky_model: '{recipe.cball_model}'
#         num_sources: 1000
#         output_column: MODEL_DATA
#         num_workers: '{recipe.nthreads}'
#         memory_fraction: 0.5

#     convertprim:
#       cab: convert
#       params:
#         output: 'msdir/ms1_primary.zarr'
#         taql_where: "FIELD_ID==0"
#         input: '{recipe.ms}'

#     converttar:
#       cab: convert
#       params:
#         output: 'msdir/ms1_target.zarr'
#         taql_where: "FIELD_ID==1"
#         input: '{recipe.ms}'


crosscal:
  name: ESOCROSSCAL
  info: The ESO137 cross calibration and diagnostics recipe

  # assign:
  #   obs: '2'

  # for_loop:
  #   var: obs
  #   over: [1, 2]
  #   scatter: 4  # to do it in parallel

  # observation specific settings in subsections
  assign_based_on:
    obs:
      '1':
        ms_primary: msdir/ms1_primary.ms
        ms_target: /scratch/bester/ms1_target.zarr
        ref_ant: 43
      '2':
        ms_primary: msdir/ms2_primary.ms
        ms_target: /scratch/bester/ms2_target.zarr
        ref_ant: 54

  inputs:
    obs:
      dtype: str
      required: true
    basedir:
      default: 'output'
    data_column:
      default: DATA
      aliases: ['*.input_ms.data_column']
    sigma_column:
      default: SIGMA_SPECTRUM
      # aliases: ['*.input_ms.sigma_column']
      info: Original std of noise used to construct weights
    weight_column:
      default: WEIGHT_SPECTRUM
      info: Modified weights to be writtent to this column
    model_column:
      dtype: str
      default: MODEL_DATA
    nthreads:
      dtype: int
      default: 32

  steps:
    # gkcal1:
    #   cab: quartical
    #   info: GK on the primary where
    #         G = per scan time variable complex gain G(t)
    #         K = per scan delay exp(i delta(t) nu)
    #   params:
    #     input_ms.path: =recipe.ms_primary
    #     input_ms.time_chunk: '0'
    #     input_ms.freq_chunk: '0'
    #     input_ms.select_uv_range: [150,0]
    #     input_ms.group_by: [FIELD_ID,DATA_DESC_ID,SCAN_NUMBER]
    #     input_ms.select_corr: [0, 3]
    #     input_model.recipe: =recipe.model_column
    #     input_model.apply_p_jones: false
    #     solver.terms: [G,K]
    #     solver.iter_recipe: [100,100,50,50]
    #     solver.propagate_flags: false
    #     solver.robust: false
    #     solver.threads: 8
    #     solver.reference_antenna: =recipe.ref_ant
    #     output.gain_directory: '{recipe.basedir}/{recipe.ms_primary}/gk1.qc'
    #     output.log_directory: '{recipe.basedir}/logs.qc'
    #     output.overwrite: true
    #     output.products:
    #     output.columns:
    #     output.flags: false
    #     output.apply_p_jones_inv: false
    #     output.net_gains:
    #     mad_flags.enable: false
    #     dask.threads: 8
    #     dask.scheduler: distributed
    #     G.type: diag_complex
    #     G.time_interval: 0
    #     G.freq_interval: 0
    #     K.type: delay
    #     K.time_interval: 0
    #     K.freq_interval: 0
    #     K.initial_estimate: true

    # bcal1:
    #   cab: quartical
    #   info: B on the primary where
    #         B = global freq variable complex gain,  G(t)
    #   params:
    #     input_ms.path: =recipe.ms_primary
    #     input_ms.time_chunk: 0
    #     input_ms.freq_chunk: 128
    #     input_ms.select_uv_range: [150,0]
    #     input_ms.group_by: [FIELD_ID,DATA_DESC_ID]
    #     input_ms.select_corr: [0, 3]
    #     input_model.recipe: =recipe.model_column
    #     input_model.apply_p_jones: false
    #     solver.terms: [G,K,B]
    #     solver.iter_recipe: [0,0,250]
    #     solver.propagate_flags: false
    #     solver.robust: false
    #     solver.threads: 8
    #     solver.reference_antenna: =recipe.ref_ant
    #     output.gain_directory: '{recipe.basedir}/{recipe.ms_primary}/b1_norob.qc'
    #     output.log_directory: '{recipe.basedir}/logs.qc'
    #     output.overwrite: true
    #     output.products:
    #     output.columns:
    #     output.flags: false
    #     output.apply_p_jones_inv: false
    #     output.net_gains: []
    #     mad_flags.enable: true
    #     mad_flags.whitening: native
    #     mad_flags.threshold_bl: 5.5
    #     mad_flags.threshold_global: 0
    #     mad_flags.max_deviation: 0
    #     dask.threads: 8
    #     dask.scheduler: distributed
    #     G.type: diag_complex
    #     G.time_interval: 0
    #     G.freq_interval: 0
    #     G.load_from: '{recipe.basedir}/{recipe.ms_primary}/gk1.qc/G'
    #     G.respect_scan_boundaries: true
    #     G.interp_mode: ampphase
    #     G.interp_method: 2dlinear
    #     K.type: delay
    #     K.time_interval: 0
    #     K.freq_interval: 0
    #     K.initial_estimate: false
    #     K.load_from: '{recipe.basedir}/{recipe.ms_primary}/gk1.qc/K'
    #     K.respect_scan_boundaries: true
    #     K.interp_mode: ampphase
    #     K.interp_method: 2dlinear
    #     B.type: diag_complex
    #     B.time_interval: 0
    #     B.freq_interval: 4
    #     B.respect_scan_boundaries: false

    # chi2plots_presmooth:
    #   cab: surfchi2
    #   info: Plot mean chisq per scan and baseline before flagging
    #   params:
    #     dataout: '{recipe.basedir}/{recipe.ms_primary}/presmooth'
    #     imagesout: '{recipe.basedir}/{recipe.ms_primary}/presmooth'
    #     wcol: SIGMA_SPECTRUM
    #     nthreads: '{recipe.nthreads}'
    #     ms: '{recipe.ms_primary}'

    # gkb_smooth:
    #   cab: quartical
    #   info: Continue solve for G and K after smoothing bandpass and madflag residuals
    #   params:
    #     input_ms.path: '{recipe.ms_primary}'
    #     input_ms.time_chunk: '0'
    #     input_ms.freq_chunk: '0'
    #     input_ms.select_uv_range: [50,0]
    #     input_ms.group_by: [FIELD_ID,DATA_DESC_ID,SCAN_NUMBER]
    #     input_ms.select_corr: [0, 3]
    #     input_model.recipe: '{recipe.model_column}'
    #     input_model.apply_p_jones: false
    #     solver.terms: [G,K,B]
    #     solver.iter_recipe: [30,30,0,20,20,0,10,10,0,5,5,0]  # both G and K can change after detrending B
    #     solver.propagate_flags: true
    #     solver.robust: true
    #     solver.threads: 1
    #     solver.reference_antenna: =recipe.ref_ant
    #     output.gain_directory: '{recipe.basedir}/{recipe.ms_primary}/gkb_smoothed.qc/'
    #     output.log_directory: '{recipe.basedir}/{recipe.ms_primary}/logs.qc'
    #     output.overwrite: true
    #     output.products: [residual]
    #     output.columns: [RESIDUAL]
    #     output.flags: true
    #     output.apply_p_jones_inv: false
    #     output.net_gains: [G,K,B]
    #     mad_flags.enable: true
    #     mad_flags.whitening: native
    #     mad_flags.threshold_bl: 4.5
    #     mad_flags.threshold_global: 0
    #     mad_flags.max_deviation: 0
    #     dask.threads: 64
    #     dask.scheduler: processes
    #     G.type: diag_complex
    #     G.time_interval: 0
    #     G.freq_interval: 0
    #     G.load_from: '{recipe.basedir}/{recipe.ms_primary}/gk1.qc/G'
    #     G.interp_mode: ampphase
    #     G.interp_method: 2dlinear
    #     K.type: delay
    #     K.time_interval: 0
    #     K.freq_interval: 0
    #     K.initial_estimate: false
    #     K.load_from: '{recipe.basedir}/{recipe.ms_primary}/gk1.qc/K'
    #     K.interp_mode: ampphase
    #     K.interp_method: 2dlinear
    #     B.type: diag_complex
    #     B.load_from: '{recipe.basedir}/{recipe.ms_primary}/b1.qc/B'
    #     B.time_interval: 0
    #     B.freq_interval: 1
    #     B.interp_mode: ampphase
    #     B.interp_method: 1dsmooth

    # chi2plots_postsmooth:
    #   cab: surfchi2
    #   info: Plot mean chisq per scan and baseline before flagging
    #   params:
    #     dataout: '{recipe.basedir}/{recipe.ms_primary}/postsmooth'
    #     imagesout: '{recipe.basedir}/{recipe.ms_primary}/svis_preflag'
    #     wcol: SIGMA_SPECTRUM
    #     nthreads: '{recipe.nthreads}'
    #     ms: '{recipe.ms_primary}'

    gkb_per_scan:
      cab: quartical
      info: Final solve to refine B solution intervals
      params:
        input_ms.path: =recipe.ms_primary
        input_ms.sigma_column: SIGMA_SPECTRUM
        input_ms.time_chunk: '0'
        input_ms.freq_chunk: '0'
        input_ms.select_uv_range: [150,0]
        input_ms.group_by: [FIELD_ID,DATA_DESC_ID,SCAN_NUMBER]
        input_ms.select_corr: [0, 3]
        input_model.recipe: =recipe.model_column
        input_model.apply_p_jones: false
        solver.terms: [G,K,B]
        solver.iter_recipe: [150,150,150,50,50,50,10,10,10]
        solver.propagate_flags: true
        solver.robust: true
        solver.threads: 8
        solver.reference_antenna: =recipe.ref_ant
        output.gain_directory: '{recipe.basedir}/{recipe.ms_primary}/gkb_per_scan_init_rob.qc/'
        output.log_directory: '{recipe.basedir}/{recipe.ms_primary}/logs.qc'
        output.overwrite: true
        # output.products: [residual]
        # output.columns: [RESIDUAL]
        output.flags: true
        output.apply_p_jones_inv: false
        # output.net_gains: [G,K,B]
        mad_flags.enable: true
        mad_flags.whitening: native
        mad_flags.threshold_bl: 3.5
        mad_flags.threshold_global: 0
        mad_flags.max_deviation: 0
        dask.threads: 8
        dask.scheduler: distributed
        G.type: diag_complex
        G.time_interval: 0
        G.freq_interval: 0
        # G.load_from:   #'{recipe.basedir}/{recipe.ms_primary}/gk1.qc/G'
        G.interp_mode: ampphase
        G.interp_method: 2dlinear
        K.type: delay
        K.time_interval: 0
        K.freq_interval: 0
        K.initial_estimate: true
        # K.load_from:   #'{recipe.basedir}/{recipe.ms_primary}/gk1.qc/K'
        # K.interp_mode: ampphase
        # K.interp_method: 2dlinear
        B.type: diag_complex
        # B.load_from: '{recipe.basedir}/{recipe.ms_primary}/b1_norob.qc/B'
        B.time_interval: 0
        B.freq_interval: 4
        # B.interp_mode: ampphase
        # B.interp_method: 2dlinear

    # chi2plots_per_scan:
    #   cab: surfchi2
    #   info: Plot mean chisq per scan and baseline before flagging
    #   params:
    #     dataout: '{recipe.basedir}/{recipe.ms_primary}/per_scan'
    #     imagesout: '{recipe.basedir}/{recipe.ms_primary}/svis_preflag'
    #     wcol: SIGMA_SPECTRUM
    #     nthreads: '{recipe.nthreads}'
    #     ms: '{recipe.ms_primary}'

    # gkb_per_scan_smooth:
    #   cab: quartical
    #   info: Final solve to refine B solution intervals
    #   params:
    #     input_ms.path: '{recipe.ms_primary}'
    #     input_ms.time_chunk: '0'
    #     input_ms.freq_chunk: '0'
    #     input_ms.select_uv_range: [150,0]
    #     input_ms.group_by: [FIELD_ID,DATA_DESC_ID,SCAN_NUMBER]
    #     input_ms.select_corr: [0, 3]
    #     input_model.recipe: '{recipe.model_column}'
    #     input_model.apply_p_jones: false
    #     solver.terms: [G,K,B]
    #     solver.iter_recipe: [30,30,0,20,20,0,10,10,0,5,5,0]
    #     solver.propagate_flags: true
    #     solver.robust: true
    #     solver.threads: 1
    #     solver.reference_antenna: =recipe.ref_ant
    #     output.gain_directory: '{recipe.basedir}/{recipe.ms_primary}/gkb_per_scan_smoothed.qc/'
    #     output.log_directory: '{recipe.basedir}/{recipe.ms_primary}/logs.qc'
    #     output.overwrite: true
    #     output.products: [residual]
    #     output.columns: [RESIDUAL]
    #     output.flags: true
    #     output.apply_p_jones_inv: false
    #     output.net_gains: [G, K, B]
    #     mad_flags.enable: true
    #     mad_flags.whitening: native
    #     mad_flags.threshold_bl: 3.5
    #     mad_flags.threshold_global: 0
    #     mad_flags.max_deviation: 0
    #     dask.threads: 64
    #     dask.scheduler: processes
    #     G.type: diag_complex
    #     G.time_interval: 0
    #     G.freq_interval: 0
    #     G.load_from: '{recipe.basedir}/{recipe.ms_primary}/gkb_per_scan.qc/G'
    #     G.interp_mode: ampphase
    #     G.interp_method: 2dlinear
    #     K.type: delay
    #     K.time_interval: 0
    #     K.freq_interval: 0
    #     K.initial_estimate: false
    #     K.load_from: '{recipe.basedir}/{recipe.ms_primary}/gkb_per_scan.qc/K'
    #     K.interp_mode: ampphase
    #     K.interp_method: 2dlinear
    #     B.type: diag_complex
    #     B.load_from: '{recipe.basedir}/{recipe.ms_primary}/gkb_per_scan.qc/B'
    #     B.time_interval: 0
    #     B.freq_interval: 1
    #     B.interp_mode: ampphase
    #     B.interp_method: 1dsmooth



    # chi2plots_final:
    #   cab: surfchi2
    #   info: Plot mean chisq per scan and baseline before transfer
    #   params:
    #     dataout: '{recipe.basedir}/{recipe.ms_primary}/final'
    #     imagesout: '{recipe.basedir}/{recipe.ms_primary}/final'
    #     wcol: SIGMA_SPECTRUM
    #     nthreads: '{recipe.nthreads}'
    #     ms: '{recipe.ms_primary}'







    calibrator_transfer:
      cab: quartical
      info: Smooth bandpass per scan and transfer solutions
      params:
        input_ms.path: '{recipe.ms_target}'
        input_ms.time_chunk: 150
        input_ms.freq_chunk: 256
        input_ms.select_uv_range: [150,0]
        input_ms.group_by: [FIELD_ID,DATA_DESC_ID,SCAN_NUMBER]
        input_ms.select_corr: [0, 3]
        input_model.recipe:
        input_model.apply_p_jones: false
        solver.terms: [G,K,B]
        solver.iter_recipe: [0,0,0]
        solver.propagate_flags: false
        solver.robust: false
        solver.threads: 1
        # solver.bypass: true
        solver.reference_antenna: =recipe.ref_ant
        output.gain_directory: '{recipe.basedir}/{recipe.ms_target}/gkb_init.qc/'
        output.log_directory: '{recipe.basedir}/{recipe.ms_target}/logs.qc'
        output.overwrite: true
        output.products:
        output.columns:
        output.flags: false
        output.apply_p_jones_inv: false
        output.net_gains: [G, K, B]
        mad_flags.enable: false
        dask.threads: 64
        dask.workers: 1
        dask.scheduler: distributed
        G.type: diag_complex
        G.time_interval: 1
        G.freq_interval: 0
        G.load_from: '{recipe.basedir}/{recipe.ms_primary}/gkb_per_scan_init_rob.qc/G'
        K.type: delay
        K.time_interval: 1
        K.freq_interval: 0
        K.initial_estimate: false
        K.load_from: '{recipe.basedir}/{recipe.ms_primary}/gkb_per_scan_init_rob.qc/K'
        K.interp_mode: ampphase
        K.interp_method: 2dlinear
        B.type: diag_complex
        B.load_from: '{recipe.basedir}/{recipe.ms_primary}/gkb_per_scan_init_rob.qc/B'
        B.time_interval: 0
        B.freq_interval: 1
        B.interp_mode: ampphase
        B.interp_method: 2dlinear


image:
  name: ESOIMAGE
  info: An imaging step of the ESO137 self-calibration recipe

  assign_based_on:
    obs:
      '1':
        ms: [/scratch/bester/ms1_target.zarr]
        gain: [/home/bester/projects/ESO137/output/scratch/bester/ms1_target.zarr/gkb_init.qc/GKB-net]
      '2':
        ms: [/scratch/bester/ms2_target.zarr]
        gain: [/home/bester/projects/ESO137/output/scratch/bester/ms2_target.zarr/gkb_init.qc/GKB-net]
      'combined':
        ms: [/scratch/bester/ms1_target.zarr, /scratch/bester/ms2_target.zarr]
        gain: [/home/bester/projects/ESO137/output/scratch/bester/ms1_target.zarr/gkb_init.qc/GKB-net,/home/bester/projects/ESO137/output/scratch/bester/ms2_target.zarr/gkb_init.qc/GKB-net]
    band:
      FULL:
        frange: 882750000:1685200000
      HI:
        frange: 1295000000:1503000000
      LO:
        frange: 980000000:1080000000

  inputs:
    obs:
      default: '2'
      info:
        Which observation to process
    band:
      default: FULL
      info: FULL, HI or LO part of the band.
    basedir:
      default: '/scratch/bester'
    log-directory:
      default: 'output/logs'
      aliases: ['*.log-directory']
    data-column:
      default: DATA
    sigma-column:
      default: SIGMA_SPECTRUM
      info: Original std of noise used to construct weights
    model-column:
      dtype: str
      default: MODEL_DATA
    nband:
      default: 10
      aliases: ['*.nband']
      info: Number of imaging bands
    scheduler:
      dtype: str
      default: distributed
      aliases: ['*.scheduler']
      info: Dask scheduler to use
    nthreads:
      dtype: int
      default: 64
    reset-cache:
      dtype: bool
      default: false
    bda-decorr:
      dtype: float
      default: 1.0
    chan-average:
      dtype: int
      default: 8

  steps:
    init:
      cab: pfb.imit
      info: 'Initialise imaging data products'
      params:
        ms: =recipe.ms
        output-filename: '{recipe.basedir}/stage1_obs{recipe.obs}_{recipe.band}'
        data-column: =recipe.data-column
        sigma-column: =recipe.sigma-column
        gain-table: =recipe.gain
        integrations-per-image: 150
        channels-per-image: 384
        nthreads-dask: 1
        nvthreads: 1
        nworkers: 64
        scheduler: distributed
        chan-average: =recipe.chan-average
        freq-range: =recipe.frange
        overwrite: true
        bda-decorr: =recipe.bda-decorr

    spotless:
      cab: pfb.spotless
      params:
        output-filename: '{recipe.basedir}/stage1_obs{recipe.obs}_{recipe.band}'
        niter: 50
        bases: 'self,db1,db2'
        nlevels: 3
        l1reweight-from: 4
        pd-tol: 3e-4
        pd-maxit: 350
        pd-verbose: 2
        pd-report-freq: 50
        tol: 1e-3
        rmsfactor: 3.0
        nthreads-dask: 1
        nvthreads: 7
        nworkers: =recipe.nband
        scheduler: distributed
        field-of-view: 2.1
        super-resolution-factor: 2.5
        robustness: -3.0
        mf-weighting: false
        l2-reweight-dof: 2.5
        l2-reweight-from: 8
        max-l2-reweight: 50
        reset-cache: =recipe.reset-cache




selfcal:
  name: ESOCAL
  info: Self-calibration

  assign_based_on:
    obs:
      '1':
        ms: /scratch/bester/ms1_target.zarr
        netgain: /home/bester/projects/ESO137/output/scratch/bester/ms1_target.zarr/gkb_init.qc/GKB-net
        ref_ant: 43
      '2':
        ms: /scratch/bester/ms2_target.zarr
        netgain: /home/bester/projects/ESO137/output/gains/ms2_target.zarr/gkb_init.qc/GKB-net
        ref_ant: 54


  inputs:
    ms:
      dtype: MS
      required: true
    basedir:
      default: '/home/bester/projects/ESO137/output/gains/ms2_target.zarr'
    data_column:
      default: DATA
    sigma_column:
      default: SIGMA_SPECTRUM
      info: Original std of noise used to construct weights
    weight_column:
      default: WEIGHT_SPECTRUM
      info: Modified weights to be written to this column
    model_column:
      dtype: str
      default: MODEL_DATA
    nthreads:
      dtype: int
      default: 32


  steps:
    selfcal1:
      cab: quartical
      info: Perfor a round of phase + delay selfcal
      params:
        input_ms.path: '{recipe.ms}'
        input_ms.data_column: DATA
        input_ms.sigma_column: SIGMA_SPECTRUM
        input_ms.time_chunk: 25
        input_ms.freq_chunk: 0
        input_ms.select_uv_range: [150,0]
        input_ms.group_by: [SCAN_NUMBER,FIELD_ID,DATA_DESC_ID]
        input_ms.select_corr: [0, 3]
        input_model.recipe: '{recipe.model_column}'
        input_model.apply_p_jones: false
        solver.terms: [G,K]
        solver.iter_recipe: [0,50,0,30,0,20,0,10,0,5]
        solver.propagate_flags: true
        solver.robust: true
        solver.threads: 2
        solver.reference_antenna: 43
        output.gain_directory: '{recipe.basedir}/stage1.qc'
        output.log_directory: '{recipe.basedir}/logs.qc'
        output.overwrite:
        output.products:
        output.columns:
        output.flags: true
        output.apply_p_jones_inv: false
        output.net_gains: [G, K]
        mad_flags.enable: true
        mad_flags.whitening: native
        mad_flags.threshold_bl: 7.5
        mad_flags.threshold_global: 0
        mad_flags.max_deviation: 0
        dask.threads: '{recipe.nthreads}'
        dask.scheduler: threads
        G.type: complex
        G.load_from: =recipe.netgain
        G.interp_method: 2dlinear
        G.interp_mode: ampphase
        G.time_interval: 1
        G.freq_interval: 1
        K.type: delay_and_offset
        K.interp_method: 2dlinear
        K.interp_mode: ampphase
        K.time_interval: 5
        K.freq_interval: 0
        K.initial_estimate: false

#     interp1:
#       cab: quartical
#       info: Interpolate gain solutions
#       params:
#         input_ms.path: '{recipe.ms}'
#         input_ms.data_column: DATA
#         input_ms.sigma_column: SIGMA_SPECTRUM
#         input_ms.time_chunk: 25
#         input_ms.freq_chunk: 0
#         input_ms.select_uv_range: [150,0]
#         input_ms.group_by: [SCAN_NUMBER,FIELD_ID,DATA_DESC_ID]
#         input_ms.select_corr: [0, 3]
#         input_model.recipe: '{recipe.model_column}'
#         input_model.apply_p_jones: false
#         solver.terms: [G,K]
#         solver.iter_recipe: [0,0]
#         solver.propagate_flags: true
#         solver.robust: false
#         solver.threads: 1
#         solver.reference_antenna: 43
#         output.gain_directory: '{recipe.basedir}/target_gains_stage1_interp.qc'
#         output.log_directory: '{recipe.basedir}/logs.qc'
#         output.overwrite: true
#         output.products: [residual]
#         output.columns: [RESIDUAL]
#         output.flags: true
#         output.apply_p_jones_inv: false
#         output.net_gains: [G, K]
#         mad_flags.enable: true
#         mad_flags.whitening: native
#         mad_flags.threshold_bl: 10
#         mad_flags.threshold_global: 10
#         mad_flags.max_deviation: 12
#         dask.threads: '{recipe.nthreads}'
#         dask.scheduler: threads
#         G.type: complex
#         G.load_from: '{recipe.basedir}/target_gains_init.qc/GKB-net'
#         G.interp_method: 2dlinear
#         G.interp_mode: ampphase
#         G.time_interval: 1
#         G.freq_interval: 1
#         K.type: delay_and_offset
#         K.interp_method: 2dlinear
#         K.interp_mode: ampphase
#         K.time_interval: 1
#         K.freq_interval: 0
#         K.initial_estimate: false
#         K.load_from: '{recipe.basedir}/target_gains_stage1.qc/K'

#     selfcal2:
#       cab: quartical
#       info: Perfor a round of phase + delay selfcal
#       params:
#         input_ms.path: '{recipe.ms}'
#         input_ms.data_column: DATA
#         input_ms.sigma_column: SIGMA_SPECTRUM
#         input_ms.time_chunk: 30
#         input_ms.freq_chunk: 0
#         input_ms.select_uv_range: [50,0]
#         input_ms.group_by: [SCAN_NUMBER,FIELD_ID,DATA_DESC_ID]
#         input_ms.select_corr: [0, 3]
#         input_model.recipe: '{recipe.model_column}'
#         input_model.apply_p_jones: false
#         solver.terms: [G,K]
#         solver.iter_recipe: [0,50,0,30,0,20,0,10,0,5]
#         solver.propagate_flags: true
#         solver.robust: true
#         solver.threads: 2
#         solver.reference_antenna: 43
#         output.gain_directory: '{recipe.basedir}/target_gains_stage2.qc'
#         output.log_directory: '{recipe.basedir}/logs.qc'
#         output.overwrite: true
#         output.flags: true
#         output.apply_p_jones_inv: false
#         mad_flags.enable: false
#         dask.threads: '{recipe.nthreads}'
#         dask.scheduler: threads
#         G.type: complex
#         G.load_from: '{recipe.basedir}/target_gains_init.qc/GKB-net'
#         G.interp_method: 2dlinear
#         G.interp_mode: ampphase
#         G.time_interval: 1
#         G.freq_interval: 1
#         K.type: delay_and_offset
#         K.interp_method: 2dlinear
#         K.interp_mode: ampphase
#         K.time_interval: 3
#         K.freq_interval: 0
#         K.initial_estimate: false
#         # K.load_from: '{recipe.basedir}/target_gains_stage1.qc/K'

#     interp2:
#       cab: quartical
#       info: Interpolate gain solutions
#       params:
#         input_ms.path: '{recipe.ms}'
#         input_ms.data_column: DATA
#         input_ms.sigma_column: SIGMA_SPECTRUM
#         input_ms.time_chunk: 30
#         input_ms.freq_chunk: 0
#         input_ms.select_uv_range: [50,0]
#         input_ms.group_by: [SCAN_NUMBER,FIELD_ID,DATA_DESC_ID]
#         input_ms.select_corr: [0, 3]
#         input_model.recipe: '{recipe.model_column}'
#         input_model.apply_p_jones: false
#         solver.terms: [G,K]
#         solver.iter_recipe: [0,0]
#         solver.propagate_flags: true
#         solver.robust: false
#         solver.threads: 1
#         solver.reference_antenna: 43
#         output.gain_directory: '{recipe.basedir}/target_gains_stage2_interp.qc'
#         output.log_directory: '{recipe.basedir}/logs.qc'
#         output.overwrite: true
#         output.products: [residual]
#         output.columns: [RESIDUAL]
#         output.flags: true
#         output.apply_p_jones_inv: false
#         output.net_gains: [G, K]
#         mad_flags.enable: true
#         mad_flags.whitening: native
#         mad_flags.threshold_bl: 7
#         mad_flags.threshold_global: 10
#         mad_flags.max_deviation: 12
#         dask.threads: '{recipe.nthreads}'
#         dask.scheduler: threads
#         G.type: complex
#         G.load_from: '{recipe.basedir}/target_gains_init.qc/GKB-net'
#         G.interp_method: 2dlinear
#         G.interp_mode: ampphase
#         G.time_interval: 1
#         G.freq_interval: 1
#         K.type: delay_and_offset
#         K.interp_method: 2dlinear
#         K.interp_mode: ampphase
#         K.time_interval: 1
#         K.freq_interval: 0
#         K.initial_estimate: false
#         K.load_from: '{recipe.basedir}/target_gains_stage2.qc/K'

#     selfcal3:
#       cab: quartical
#       info: Perfor a round of phase + delay selfcal
#       params:
#         input_ms.path: '{recipe.ms}'
#         input_ms.data_column: DATA
#         input_ms.sigma_column: SIGMA_SPECTRUM
#         input_ms.time_chunk: 30
#         input_ms.freq_chunk: 0
#         input_ms.select_uv_range: [50,0]
#         input_ms.group_by: [SCAN_NUMBER,FIELD_ID,DATA_DESC_ID]
#         input_ms.select_corr: [0, 3]
#         input_model.recipe: '{recipe.model_column}'
#         input_model.apply_p_jones: false
#         solver.terms: [G,K]
#         solver.iter_recipe: [0,50,0,30,0,20,0,10,0,5]
#         solver.propagate_flags: true
#         solver.robust: true
#         solver.threads: 2
#         solver.reference_antenna: 43
#         output.gain_directory: '{recipe.basedir}/target_gains_stage3.qc'
#         output.log_directory: '{recipe.basedir}/logs.qc'
#         output.overwrite: true
#         output.flags: true
#         output.apply_p_jones_inv: false
#         mad_flags.enable: false
#         dask.threads: '{recipe.nthreads}'
#         dask.scheduler: threads
#         G.type: complex
#         G.load_from: '{recipe.basedir}/target_gains_init.qc/GKB-net'
#         G.interp_method: 2dlinear
#         G.interp_mode: ampphase
#         G.time_interval: 1
#         G.freq_interval: 1
#         K.type: delay_and_offset
#         K.interp_method: 2dlinear
#         K.interp_mode: ampphase
#         K.time_interval: 3
#         K.freq_interval: 0
#         K.initial_estimate: false
#         # K.load_from: '{recipe.basedir}/target_gains_stage1.qc/K'

#     interp3:
#       cab: quartical
#       info: Interpolate gain solutions
#       params:
#         input_ms.path: '{recipe.ms}'
#         input_ms.data_column: DATA
#         input_ms.sigma_column: SIGMA_SPECTRUM
#         input_ms.time_chunk: 30
#         input_ms.freq_chunk: 0
#         input_ms.select_uv_range: [50,0]
#         input_ms.group_by: [SCAN_NUMBER,FIELD_ID,DATA_DESC_ID]
#         input_ms.select_corr: [0, 3]
#         input_model.recipe: '{recipe.model_column}'
#         input_model.apply_p_jones: false
#         solver.terms: [G,K]
#         solver.iter_recipe: [0,0]
#         solver.propagate_flags: true
#         solver.robust: false
#         solver.threads: 1
#         solver.reference_antenna: 43
#         output.gain_directory: '{recipe.basedir}/target_gains_stage3_interp.qc'
#         output.log_directory: '{recipe.basedir}/logs.qc'
#         output.overwrite: true
#         output.products: [residual]
#         output.columns: [RESIDUAL]
#         output.flags: true
#         output.apply_p_jones_inv: false
#         output.net_gains: [G, K]
#         mad_flags.enable: true
#         mad_flags.whitening: native
#         mad_flags.threshold_bl: 7
#         mad_flags.threshold_global: 10
#         mad_flags.max_deviation: 12
#         dask.threads: '{recipe.nthreads}'
#         dask.scheduler: threads
#         G.type: complex
#         G.load_from: '{recipe.basedir}/target_gains_init.qc/GKB-net'
#         G.interp_method: 2dlinear
#         G.interp_mode: ampphase
#         G.time_interval: 1
#         G.freq_interval: 1
#         K.type: delay_and_offset
#         K.interp_method: 2dlinear
#         K.interp_mode: ampphase
#         K.time_interval: 1
#         K.freq_interval: 0
#         K.initial_estimate: false
#         K.load_from: '{recipe.basedir}/target_gains_stage3.qc/K'


# sanity:
#   name: sanity
#   info:
#     Sanity check to make sure pfb and qcal produce consistent results.
#     Fixed model degridded to MODEL_DATA at high resolution (64 bands)
#     and to MODEL_DATA_LR at a resolution (8 bands) that mathches the size of the image.
#     We have to check that
#     i) imaging the corrected products at low resolution gives the same result as computing
#        the residual with the grid worker while applying the gains on the fly
#     ii) the calibration improves when using the high resolution model
#     iii) it improves further when interpolating the gains to a higher resolution

#   inputs:
#     ms:
#       dtype: MS
#       required: true
#     basedir:
#       default: 'output_sanity_no_delay_clunking_smoothB_reflag'
#     model:
#       default: '/scratch/bester/stage3_I_main_model.coeffs.zarr'
#     input_gains:
#       default: 'output_infG/target_gains_init_nodelay_clunking_smoothB.qc'

#   steps:
#     # predict_low_res:
#     #   cab: pfb_degrid
#     #   params:
#     #     ms: =recipe.ms
#     #     output_filename: '/scratch/bester/stage3'
#     #     channels_per_image: 512
#     #     integrations_per_image: -1
#     #     model_column: MODEL_DATA_LR
#     #     nthreads_dask: 4
#     #     nvthreads: 16
#     #     scheduler: threads

#     # predict_high_res:
#     #   cab: pfb_degrid
#     #   params:
#     #     ms: =recipe.ms
#     #     output_filename: '/scratch/bester/stage3'
#     #     channels_per_image: 64
#     #     integrations_per_image: -1
#     #     model_column: MODEL_DATA
#     #     nthreads_dask: 8
#     #     nvthreads: 8
#     #     scheduler: threads

#     # low_res_cal:
#     #     cab: quartical
#     #     info: Perform phase + delay selfcal with low res model
#     #     params:
#     #       input_ms.path: '{recipe.ms}'
#     #       input_ms.data_column: DATA
#     #       input_ms.sigma_column: SIGMA_SPECTRUM
#     #       input_ms.time_chunk: 30
#     #       input_ms.freq_chunk: 0
#     #       input_ms.select_uv_range: [0,0]
#     #       input_ms.group_by: [SCAN_NUMBER,FIELD_ID,DATA_DESC_ID]
#     #       input_ms.select_corr: [0, 3]
#     #       input_model.recipe: MODEL_DATA_LR
#     #       input_model.apply_p_jones: false
#     #       solver.terms: [G,K]
#     #       solver.iter_recipe: [0,200]
#     #       solver.propagate_flags: true
#     #       solver.robust: false
#     #       solver.threads: 2
#     #       solver.reference_antenna: 43
#     #       output.gain_directory: '{recipe.basedir}/low_res.qc'
#     #       output.log_directory: '{recipe.basedir}/logs.qc'
#     #       output.overwrite: true
#     #       output.flags: true
#     #       output.apply_p_jones_inv: false
#     #       output.net_gains: [G, K]
#     #       output.products: [corrected_residual, corrected_weight]
#     #       output.columns: [RESIDUAL, WEIGHT_SPECTRUM]
#     #       mad_flags.enable: false
#     #       dask.threads: 32
#     #       dask.scheduler: threads
#     #       G.type: complex
#     #       G.load_from: 'output_infG/target_gains_init.qc/GKB-net'
#     #       G.interp_method: 2dlinear
#     #       G.interp_mode: ampphase
#     #       G.time_interval: 1
#     #       G.freq_interval: 1
#     #       K.type: delay_and_offset
#     #       K.interp_method: 2dlinear
#     #       K.interp_mode: ampphase
#     #       K.time_interval: 3
#     #       K.freq_interval: 0
#     #       K.initial_estimate: false

#     # init_corrected:
#     #   cab: pfb_init
#     #   info:
#     #     Initialise imaging data products at low res
#     #   params:
#     #     ms: '{recipe.ms}'
#     #     output_filename: '{recipe.basedir}/low_res_corrected'
#     #     data_column: RESIDUAL
#     #     weight_column: WEIGHT_SPECTRUM
#     #     integrations_per_image: -1
#     #     channels_per_image: 512
#     #     nthreads_dask: 4
#     #     nvthreads: 8
#     #     scheduler: threads

#     # grid_corrected:
#     #   cab: pfb_grid
#     #   params:
#     #     output_filename: '{recipe.basedir}/low_res_corrected'
#     #     nband: 8
#     #     robustness: 0.0
#     #     fits_cubes: true
#     #     field_of_view: 2.5
#     #     super_resolution_factor: 2.0
#     #     nvthreads: 8
#     #     nthreads_dask: 8
#     #     weight: false
#     #     psf: false

#     # init_forward:
#     #   cab: pfb_init
#     #   info:
#     #     Initialise imaging data products at low res
#     #   params:
#     #     ms: '{recipe.ms}'
#     #     output_filename: '{recipe.basedir}/low_res_forward'
#     #     data_column: DATA
#     #     sigma_column: SIGMA_SPECTRUM
#     #     gain_table: '{recipe.basedir}/low_res.qc'
#     #     gain_term: 'GK-net'
#     #     integrations_per_image: -1
#     #     channels_per_image: 512
#     #     nthreads_dask: 4
#     #     nvthreads: 8
#     #     scheduler: threads

#     # grid_forward:
#     #   cab: pfb_grid
#     #   params:
#     #     output_filename: '{recipe.basedir}/low_res_forward'
#     #     nband: 8
#     #     robustness: 0.0
#     #     fits_cubes: true
#     #     field_of_view: 2.5
#     #     super_resolution_factor: 2.0
#     #     nvthreads: 8
#     #     nthreads_dask: 8
#     #     weight: false
#     #     psf: false
#     #     residual: true
#     #     transfer_model_from: '{recipe.model}'

#     high_res_cal:
#         cab: quartical
#         info: Perform phase + delay selfcal with high res model
#         params:
#           input_ms.path: '{recipe.ms}'
#           input_ms.data_column: DATA
#           input_ms.sigma_column: SIGMA_SPECTRUM
#           input_ms.time_chunk: 30
#           input_ms.freq_chunk: 0
#           input_ms.select_uv_range: [0,0]
#           input_ms.group_by: [SCAN_NUMBER,FIELD_ID,DATA_DESC_ID]
#           input_ms.select_corr: [0, 3]
#           input_model.recipe: MODEL_DATA
#           input_model.apply_p_jones: false
#           solver.terms: [G,K]
#           solver.iter_recipe: [0,0]
#           solver.propagate_flags: true
#           solver.robust: true
#           solver.threads: 2
#           solver.reference_antenna: 43
#           output.gain_directory: '{recipe.basedir}/high_res_no_clunking_smoothB_reflag.qc'
#           output.log_directory: '{recipe.basedir}/logs.qc'
#           output.overwrite: true
#           output.flags: true
#           output.apply_p_jones_inv: false
#           output.net_gains: [G, K]
#           output.products: [residual]
#           output.columns: [RESIDUAL]
#           mad_flags.enable: false
#           dask.threads: 32
#           dask.scheduler: threads
#           G.type: complex
#           G.load_from: '{recipe.input_gains}/GKB-net'
#           G.interp_method: 2dlinear
#           G.interp_mode: ampphase
#           G.time_interval: 1
#           G.freq_interval: 1
#           K.type: delay_and_offset
#           K.load_from: '/home/bester/projects/ESO137/output_sanity_no_delay_clunking_smoothB/high_res_no_clunking_smoothB.qc/K'
#           K.interp_method: 2dlinear
#           K.interp_mode: ampphase
#           K.time_interval: 3
#           K.freq_interval: 0
#           K.initial_estimate: false

#     init_corrected_high_res:
#       cab: pfb_init
#       info:
#         Initialise imaging data products at low res
#       params:
#         ms: '{recipe.ms}'
#         output_filename: '{recipe.basedir}/high_res_corrected_smoothB_reflag'
#         data_column: RESIDUAL
#         sigma_column: SIGMA_SPECTRUM
#         gain_table: '{recipe.basedir}/high_res_no_clunking_smoothB_reflag.qc'
#         gain_term: 'GK-net'
#         integrations_per_image: -1
#         channels_per_image: 512
#         nthreads_dask: 4
#         nvthreads: 8
#         scheduler: threads

#     grid_corrected_high_res:
#       cab: pfb_grid
#       params:
#         output_filename: '{recipe.basedir}/high_res_corrected_smoothB_reflag'
#         nband: 8
#         robustness: 0.0
#         fits_cubes: true
#         field_of_view: 2.5
#         super_resolution_factor: 2.0
#         nvthreads: 8
#         nthreads_dask: 8
#         weight: false
#         psf: false

    # init_forward_high_res:
    #   cab: pfb_init
    #   info:
    #     Initialise imaging data products at low res
    #   params:
    #     ms: '{recipe.ms}'
    #     output_filename: '{recipe.basedir}/high_res_forward'
    #     data_column: DATA
    #     sigma_column: SIGMA_SPECTRUM
    #     gain_table: '{recipe.basedir}/high_res.qc'
    #     gain_term: 'GK-net'
    #     integrations_per_image: -1
    #     channels_per_image: 512
    #     nthreads_dask: 4
    #     nvthreads: 8
    #     scheduler: threads

    # grid_forward_high_res:
    #   cab: pfb_grid
    #   params:
    #     output_filename: '{recipe.basedir}/high_res_forward'
    #     nband: 8
    #     robustness: 0.0
    #     fits_cubes: true
    #     field_of_view: 2.5
    #     super_resolution_factor: 2.0
    #     nvthreads: 8
    #     nthreads_dask: 8
    #     weight: false
    #     psf: false
    #     residual: true
    #     transfer_model_from: '{recipe.model}'


# IR = R.H G.H (V - G R2 H theta),    x2 = H theta
# IR = ID - R.H G.H G R x,  s.t. x > 0
