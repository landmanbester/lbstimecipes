_include:
  - lb-cabs.yaml
  - (pfb)stimela_cabs.yaml
  - (lbscratch)stimela_cabs.yaml
  - (quartical)stimela_cabs.yaml

opts:
  log:
    dir: logs
    nest: 2


# Missing features
# 1) both simplyflag and crystallbal relies on MS format
# 2) QuartiCal apps need to have FIELD, DDID and SPW selection logic
# 3) can't convert over NFS

init:
  name: INIT
  info: Back up initial flags, do initial flagging, predict primary model and split data

  # LB - Oleg to help do this in a neater way
  # for_loop:
  #   var: ms
  #   over: ms_list

  inputs:
    # ms_list:
    # dtype: List[str]
    # default:
    #   - /net/sinatra/vault-ike/oms/MeerKAT-data/ESO137/1557347448_sdp_l0.ms  # ms1
    #   - /net/sinatra/vault-ike/oms/MeerKAT-data/ESO137/1557433849_sdp_l0.ms  # ms2

    ms1:
      default: /net/sinatra/vault-ike/oms/MeerKAT-data/ESO137/1557347448_sdp_l0.ms
    ms2:
      default: /net/sinatra/vault-ike/oms/MeerKAT-data/ESO137/1557433849_sdp_l0.ms
    basedir:
      default: 'output'
    cball_model:
      default: 'input/fitted.PKS1934.UBand.wsclean.cat.txt'
    nthreads:
      default: 32
    fmask:
      dtype: str
      default: ':128,2697:2705,-256:'
      info: Channel ranges to flag

  steps:
    backup_flag_raw:
      cab: qcalbackup
      info: 'Back up original MS flags'
      params:
        ms_path: '{recipe.ms}'
        zarr_dir: '{recipe.basedir}/initial_flags/'
        column: FLAG

    backup_flagrow_raw:
      cab: qcalbackup
      info: 'Back up original MS flags'
      params:
        ms_path: '{recipe.ms}'
        zarr_dir: '{recipe.basedir}/initial_flags'
        column: FLAG_ROW

    flagprim:
      cab: simplyflag
      params:
        path: '{recipe.ms}'
        field: 0
        max_deviation: 2.5

    flagtar:
      cab: simplyflag
      params:
        path: '{recipe.ms}'
        field: 1
        max_deviation: 3.5

    flag_edges:  # mapped over field?
      cab: fledges
      info: Apply fixed frequency flag mask
      params:
        ms: "{recipe.ms}"
        row_chunk: -1
        franges: '{recipe.fmask}'
        nthreads: '{recipe.nthreads}'

    backup_flag:
      cab: qcalbackup
      info: 'Back up original MS flags'
      params:
        ms_path: '{recipe.ms}'
        zarr_dir: '{recipe.basedir}/initial_flags/'
        column: FLAG

    backup_flagrow:
      cab: qcalbackup
      info: 'Back up original MS flags'
      params:
        ms_path: '{recipe.ms}'
        zarr_dir: '{recipe.basedir}/initial_flags'
        column: FLAG_ROW

    combine_flags:
      cab: or_flags
      params:
        ms: =recipe.ms
        fcol: 'FLAG'  # need to use outputs for these
        frcol: 'FLAG_ROW'

    init_model:  # we should do this after convert but crystalball needs MS format
      cab: crystalball
      info: 'Populate MODEL_DATA column'
      params:
        ms: '{recipe.ms}'
        sky_model: '{recipe.cball_model}'
        num_sources: 1000
        output_column: MODEL_DATA
        num_workers: '{recipe.nthreads}'
        memory_fraction: 0.5

    convertprim:
      cab: convert
      params:
        output: 'msdir/ms1_primary.zarr'
        taql_where: "FIELD_ID==0"
        input: '{recipe.ms}'

    converttar:
      cab: convert
      params:
        output: 'msdir/ms1_target.zarr'
        taql_where: "FIELD_ID==1"
        input: '{recipe.ms}'


crosscal:
  name: CROSSCAL
  info: The ESO137 cross calibration and diagnostics recipe

  inputs:
    ms_primary:
      dtype: MS
      required: true
      abbreviation: msp
    ms_target:
      dtype: MS
      required: true
      abbreviation: mst
    basedir:
      default: 'output'
    data_column:
      default: DATA
      aliases: ['*.input_ms.data_column']
    sigma_column:
      default: SIGMA_SPECTRUM
      aliases: ['*.input_ms.sigma_column']
      info: Original std of noise used to construct weights
    weight_column:
      default: WEIGHT_SPECTRUM
      info: Modified weights to be writtent to this column
    model_column:
      dtype: str
      default: MODEL_DATA
    nthreads:
      dtype: int
      default: 32

  steps:
    # we need the restimator step here but how do we use the output??

    gkb1:
      cab: quartical
      info: GKB on the primary where
            G = time variable complex gain,
            K = per scan delay refinement
            B = frequency variable complex gain (bandpass)
      params:
        input_ms.path: '{recipe.ms_primary}'
        input_ms.time_chunk: '0'
        input_ms.freq_chunk: '0'
        input_ms.select_uv_range: [150,0]
        input_ms.group_by: [FIELD_ID,DATA_DESC_ID,SCAN_NUMBER]
        input_ms.select_corr: [0, 3]
        input_model.recipe: '{recipe.model_column}'
        input_model.apply_p_jones: false
        solver.terms: [G,K,B]
        solver.iter_recipe: [100,100,100,50,50,50,30,30,30,10,10,10]
        solver.propagate_flags: false
        solver.robust: true
        solver.threads: 8
        solver.reference_antenna: 43
        output.gain_directory: '{recipe.basedir}/gkb1.qc'
        output.log_directory: '{recipe.basedir}/logs.qc'
        output.overwrite: false
        output.products: [residual]
        output.columns: [RESIDUAL]
        output.flags: false
        output.apply_p_jones_inv: false
        output.net_gains: []
        mad_flags.enable: false
        dask.threads: 8
        dask.scheduler: threads
        G.type: complex
        G.time_interval: 18
        G.freq_interval: 0
        K.type: delay
        K.time_interval: 0
        K.freq_interval: 0
        K.initial_estimate: true
        B.type: complex
        B.time_interval: 0
        B.freq_interval: 8

    chi2plots_preflagsmooth:
      cab: surfchi2
      info: Plot mean chisq per scan and baseline before flagging
      params:
        dataout: '{recipe.basedir}/svis_preflagsmooth'
        imagesout: '{recipe.basedir}/svis_preflagsmooth'
        wcol: SIGMA_SPECTRUM
        nthreads: '{recipe.nthreads}'
        ms: '{recipe.ms_primary}'

    bsmooth:
      cab: bsmooth
      info: Smooth weighted average bandpass solutions
      params:
        gain_dir: '{recipe.basedir}/gkb1.qc/'  # smoothed bandpass will be in smoothed.qc next to this folder
        gain_term: B
        reject_amp_thresh: 5.5
        reject_phase_thresh: 55.5
        do_plots: true
        nthreads: =recipe.nthreads
        ref_ant: 43
        dof0: 2.0
        nreweight: 10
        sigman_min: 0.005

    gsmooth:
      cab: gsmooth
      info: Transfer K offset to G and optionally smooth
      params:
        gain_dir: '{recipe.basedir}/gkb1.qc/'  # smoothed bandpass will be in smoothed.qc next to this folder
        gain_term: G
        do_plots: true
        nthreads: =recipe.nthreads
        do_smooth: False
        ref_ant: 43

    gkb2:
      cab: quartical
      info: Continue solve for K after smoothing bandpass and compute residual for flagging
      params:
        input_ms.path: '{recipe.ms_primary}'
        input_ms.time_chunk: '0'
        input_ms.freq_chunk: '0'
        input_ms.select_uv_range: [150,0]
        input_ms.group_by: [FIELD_ID,DATA_DESC_ID,SCAN_NUMBER]
        input_ms.select_corr: [0, 3]
        input_model.recipe: '{recipe.model_column}'
        input_model.apply_p_jones: false
        solver.terms: [G,K,B]
        solver.iter_recipe: [20,20,0,10,10,0,5,5,0]  # both G and K can change after detrending B
        solver.propagate_flags: false
        solver.robust: true
        solver.threads: 8
        solver.reference_antenna: 43
        output.gain_directory: '{recipe.basedir}/gkb2.qc/'
        output.log_directory: '{recipe.basedir}/logs.qc'
        output.overwrite: false
        output.products: [residual]
        output.columns: [RESIDUAL]
        output.flags: false
        output.apply_p_jones_inv: false
        output.net_gains:
        mad_flags.enable: false
        dask.threads: 8
        dask.scheduler: distributed
        G.type: complex
        G.time_interval: 18
        G.freq_interval: 0
        G.load_from: '{recipe.basedir}/gkb1.qc/G'
        K.type: delay
        K.time_interval: 0
        K.freq_interval: 0
        K.initial_estimate: false
        K.load_from: '{recipe.basedir}/gkb1.qc/K'
        B.type: complex
        B.load_from: '{recipe.basedir}/gkb1.qc/B'
        B.time_interval: 0
        B.freq_interval: 8

    chi2plots_preflag:
      cab: surfchi2
      info: Plot mean chisq per scan and baseline before flagging
      params:
        dataout: '{recipe.basedir}/svis_preflag'
        imagesout: '{recipe.basedir}/svis_preflag'
        wcol: SIGMA_SPECTRUM
        nthreads: '{recipe.nthreads}'
        ms: '{recipe.ms_primary}'

    chi2flag:
      cab: flagchi2
      info: Flag individual data points based on their chi2 values
      params:
        wcol: SIGMA_SPECTRUM
        nthreads: '{recipe.nthreads}'
        ms: '{recipe.ms_primary}'
        flag_above: 3.5
        unflag_below: 0.0

    chi2plots_postflag:
      cab: surfchi2
      info: Plot mean chisq per scan and baseline after flagging
      params:
        dataout: '{recipe.basedir}/svis_postflag'
        imagesout: '{recipe.basedir}/svis_postflag'
        wcol: SIGMA_SPECTRUM
        nthreads: '{recipe.nthreads}'
        ms: '{recipe.ms_primary}'

    gkb3:
      cab: quartical
      info: Final solve to refine B solution intervals
      params:
        input_ms.path: '{recipe.ms_primary}'
        input_ms.time_chunk: '0'
        input_ms.freq_chunk: '0'
        input_ms.select_uv_range: [150,0]
        input_ms.group_by: [FIELD_ID,DATA_DESC_ID,SCAN_NUMBER]
        input_ms.select_corr: [0, 3]
        input_model.recipe: '{recipe.model_column}'
        input_model.apply_p_jones: false
        solver.terms: [G,K,B]
        solver.iter_recipe: [20,20,20,10,10,10,5,5,5]
        solver.propagate_flags: false
        solver.robust: true
        solver.threads: 8
        solver.reference_antenna: 43
        output.gain_directory: '{recipe.basedir}/gkb3.qc/'
        output.log_directory: '{recipe.basedir}/logs.qc'
        output.overwrite: false
        output.products: [residual]
        output.columns: [RESIDUAL]
        output.flags: false
        output.apply_p_jones_inv: false
        output.net_gains:
        mad_flags.enable: false
        dask.threads: 8
        dask.scheduler: distributed
        G.type: complex
        G.time_interval: 18
        G.freq_interval: 0
        G.load_from: '{recipe.basedir}/gkb2.qc/G'
        K.type: pure_delay
        K.time_interval: 0
        K.freq_interval: 0
        K.initial_estimate: false
        K.load_from: '{recipe.basedir}/gkb2.qc/K'
        B.type: complex
        B.load_from: '{recipe.basedir}/gkb2.qc/B'
        B.time_interval: 0
        B.freq_interval: 2

    chi2plots_final:
      cab: surfchi2
      info: Plot mean chisq per scan and baseline before transfer
      params:
        dataout: '{recipe.basedir}/svis_final'
        imagesout: '{recipe.basedir}/svis_final'
        wcol: SIGMA_SPECTRUM
        nthreads: '{recipe.nthreads}'
        ms: '{recipe.ms_primary}'

    bsmooth2:
      cab: bsmooth
      info: Smooth weighted average bandpass solutions
      params:
        gain_dir: '{recipe.basedir}/gkb3.qc/'  # smoothed bandpass will be in smoothed.qc next to this folder
        gain_term: B
        reject_amp_thresh: 5.5
        reject_phase_thresh: 55.5
        do_plots: true
        per_scan: true
        nthreads: =recipe.nthreads
        ref_ant: 43
        detrend: false
        dof0: 4.0
        nreweight: 5
        sigman_min: 0.0001


    transfer:
      cab: quartical
      info: "Transfer gains to the targer"
      params:
        input_ms.path: '{recipe.ms_target}'
        input_ms.time_chunk: 0
        input_ms.freq_chunk: 256
        input_ms.group_by: [SCAN_NUMBER,FIELD_ID,DATA_DESC_ID]
        input_ms.select_corr: [0, 3]
        input_model.recipe:
        input_model.apply_p_jones: false
        solver.terms: [G,K,B]
        solver.iter_recipe: [0,0,0]
        solver.propagate_flags: false
        solver.robust: false
        solver.threads: 8
        solver.reference_antenna: 43
        output.gain_directory: '{recipe.basedir}/target_gains_init.qc'
        output.log_directory: '{recipe.basedir}/logs.qc'
        output.overwrite: false
        output.products: [corrected_data, corrected_weight]
        output.columns: [CORRECTED_DATA, WEIGHT_SPECTRUM]
        output.flags: false
        output.apply_p_jones_inv: false
        output.net_gains: [G, K, B]
        mad_flags.enable: false
        dask.threads: 8
        dask.scheduler: threads
        G.type: complex
        G.time_interval: 1
        G.freq_interval: 0
        G.load_from: '{recipe.basedir}/gkb2.qc/G'
        K.type: pure_delay
        K.time_interval: 0
        K.freq_interval: 0
        K.initial_estimate: false
        K.load_from: '{recipe.basedir}/gkb2.qc/K'
        B.type: complex
        B.time_interval: 0
        B.freq_interval: 1
        B.load_from: '{recipe.basedir}/gkb3.qc/smoothed.qc/B'

# image:
#   name: ESOIMAGE
#   info: An imaging step of the ESO137 self-calibration recipe

#   inputs:
#     ms:
#       dtype: MS
#       required: true
#     basedir:
#       default: 'output'
#     data_column:
#       default: DATA
#       aliases: ['*.input_ms.data_column']
#     sigma_column:
#       default: SIGMA_SPECTRUM
#       aliases: ['*.input_ms.sigma_column']
#       info: Original std of noise used to construct weights
#     weight_column:
#       default: WEIGHT_SPECTRUM
#       info: Modified weights to be writtent to this column
#     model_column:
#       dtype: str
#       default: MODEL_DATA
#     nband:
#       default: 8
#       aliases: ['*.nband']
#       info: Number of imaging bands
#     scheduler:
#       dtype: str
#       default: threads
#       aliases: ['*.scheduler']
#       info: Dask scheduler to use
#     nthreads:
#       dtype: int
#       default: 64

#   steps:
#     init1:
#       cab: pfb_init
#       info: 'Initialise imaging data products'
#       params:
#         ms: '{recipe.ms}'
#         output_filename: '{recipe.basedir}/stage1'
#         data_column: DATA
#         sigma_column: SIGMA_SPECTRUM
#         gain_table: '{recipe.basedir}/target_gains_init.qc/'
#         gain_term: 'GKB-net'
#         integrations_per_image: -1
#         channels_per_image: 256
#         nthreads: '{recipe.nthreads}'
#         nworkers: 8
#         nthreads_per_worker: 8
#         scheduler: threads

#     grid1:
#       cab: pfb_grid
#       info: 'Grid data for initial imaging'
#       params:
#         output_filename: '{recipe.basedir}/stage1'
#         robustness: -1
#         fits_cubes: true
#         field_of_view: 2.5
#         super_resolution_factor: 1.5
#         nthreads: '{recipe.nthreads}'
#         nworkers: 8

#     spotless1:
#       cab: pfb_spotless
#       params:
#         output_filename: '{recipe.basedir}/stage1'
#         fits_cubes: true
#         niter: 10
#         nthreads: '{recipe.nthreads}'
#         bases: 'self,db1,db2,db3,db4,db5'
#         nlevels: 3
#         l1reweight_from: 5
#         pd_tol: 1e-4
#         pd_maxit: 500
#         pd_verbose: 2
#         pd_report_freq: 50
#         tol: 0.001
#         rmsfactor: 5
#         pm_tol: 1e-4

#     # forward
#     # grid with reweight
#     # spotless
#     # forward

#     degrid1:
#       cab: pfb_degrid
#       info: Populate MODEL_DATA with model visibilities
#       params:
#         ms: '{recipe.ms}'
#         output_filename: '{recipe.basedir}/stage1'
#         nband_out: 32
#         spectral_poly_order: 4


# selfcal:
#   name: ESOCAL
#   info: Self-calibration

#   steps:
#     selfcal1:
#       cab: quartical
#       info: First round of selfcal
#       params:
#         input_ms.path: '{recipe.ms}'
#         input_ms.time_chunk: 4
#         input_ms.freq_chunk: 0
#         input_ms.select_uv_range: [0, 250]
#         input_ms.group_by: [SCAN_NUMBER,FIELD_ID,DATA_DESC_ID]
#         input_ms.select_corr: [0, 3]
#         input_model.recipe: '{recipe.model_column}'
#         input_model.apply_p_jones: false
#         solver.terms: [G,K]
#         solver.iter_recipe: [0,40,0,20,0,10,0,5]
#         solver.propagate_flags: true
#         solver.robust: true
#         solver.reweighting_flag_threshold: 0.01
#         solver.threads: 1
#         solver.reference_antenna: 57
#         output.directory: '{recipe.basedir}/target_gains_stage1.qc'
#         output.overwrite: true
#         output.products: [residual]
#         output.columns: [RESIDUAL]
#         output.flags: true
#         output.apply_p_jones_inv: false
#         output.net_gain: true
#         mad_flags.enable: false
#         dask.threads: '{recipe.nthreads}'
#         dask.scheduler: threads
#         G.type: complex
#         G.load_from: '{recipe.basedir}/target_gains_init.qc/gains.qc/NET'
#         G.interp_method: 2dlinear
#         G.interp_mode: ampphase
#         G.time_interval: 1
#         G.freq_interval: 0
#         K.type: delay
#         K.load_from:
#         K.interp_method: 2dlinear
#         K.interp_mode: ampphase
#         K.time_interval: 4
#         K.freq_interval: 0
#         K.initial_estimate: false
